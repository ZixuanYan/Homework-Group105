# 实验名称
**SM3项目分类** 

# 实验内容
1. Project1: SM3 生日攻击；
2. Project2: SM3 Rho攻击；
3. Project3: SM3 长度扩展攻击；
4. Project4: SM3 优化加速；

# 作者
姓名：闫子轩

组号：Group105

学号：202100460160

Github账户地址：https://github.com/ZixuanYan

# 软件环境

编译器：Python 3.10，Visual Studio 2019

# 生日攻击

首先需要定义一些辅助函数和常量，包括左移函数leftshift、FF和GG函数、P0和P1函数、T函数以及初始向量IV等。

然后padding函数，用于对输入消息进行填充，使其长度满足SM3算法的要求。

接下来的block函数将填充后的消息按照128比特分块。

message_extension函数根据分块后的消息生成消息扩展，其中使用了W和W1两个列表存储中间结果。

message_compress函数根据消息扩展对当前块进行压缩运算。

最后的SM3函数将所有分块进行压缩运算得到最终的输出。

randomnum函数生成指定数量的随机数。

brithday_attack函数实现了生日攻击，它首先生成2^16个随机数，并利用padding、block和SM3函数获得对应的哈希值。然后统计哈希值的出现次数，找出重复的哈希值，利用哈希函数发生碰撞的可能性，进行n次尝试直到找到一对碰撞的输入。

最终成功攻击输出值为28比特的SM3函数。

## 运行结果

![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/pic1.png)

# Rho攻击

Rho攻击是一种密码分析技术，主要用于寻找哈希函数中的碰撞，Rho攻击用于破解SM3哈希算法。

Rho攻击的基本思想是通过生成一系列随机输入，并计算它们的哈希值，然后检查是否存在相同的哈希值（即碰撞）。如果发现碰撞，那么就可以推断出哈希函数存在弱点。

在Rho攻击函数中首先生成随机64位数r，然后将r转换为填充后的消息m。接下来，将m切分成128位的块，对每个块执行哈希运算，得到哈希结果Mn。然后，提取Mn的第一个字节并检查是否在已生成的随机值列表中出现过。如果出现重复，说明此时已经成环，找到了碰撞，攻击成功，否则将该字节加入已生成的随机值列表。
## 运行结果
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/pic2.png)

# 长度扩展攻击

## MD结构
MD结构首先对输入消息进行填充，让消息变成固定长度的整数倍（比如512或者1024）。这是因为压缩算法是不能对任意长度的消息进行处理的，所以在处理之前必须进行填充。通常来说，我们会使用0来填充整个消息块。

但是这样做往往是不够的，因为通常对于压缩函数来说，会删除掉最后面的额外的0，所以导致填充和不填充最后计算出来的hash值是一样的。

为避免这种情况，必须更改填充常量数据的第一位。由于常量填充通常由零组成，因此第一个填充位将强制更改为“ 1”。

流程图如下：

![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230719191149.png)

## 长度扩展攻击

长度扩展攻击是一种针对哈希函数的攻击方式，利用已知哈希值和初始向量构造合法的消息，并生成新的哈希值。

攻击者通过已知的hash(message1)和message1的长度，从而能够知道hash（message1‖message2）的值。其中‖ 表示的是连接符。并且攻击性并需要知道message1到底是什么。

攻击流程图如下所示：
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230719191657.png)

攻击过程如下：
1. 对任意消息r1，首先对其进行填充，得到 m=r1||padding；
2. 调用SM3计算哈希值即 h1=SM3(m,IV)；
3. 自选r2作为进行攻击的消息，计算 h2=SM3(m||r2,IV)即h2=SM3(r1||padding||r2,IV)；
4. 计算 h3=SM3(r2,iv)，其中iv=h1即先前消息的哈希值；
5. 比较h2与h3是否相同，若相同，则攻击成功。

## 运行结果
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230719193451.png)
# SM3优化加速
## SM3算法实现
SM3算法主要包括数据填充、数据扩展和迭代压缩三个过程。
## 优化思路
根据所学知识，可以从以下几个方向考虑：
1. 并行计算：利用多线程或并行处理器进行计算，将消息分块后并行处理，加快计算速度。
2. 硬件加速：使用专用硬件来执行SM3算法，如GPU或FPGA等。
3. 优化代码实现：对SM3算法的代码进行优化，例如使用更高效的数据结构、算法和编程技巧，减少不必要的计算、内存读写等操作，提高代码执行效率。
4. 预计算表：对SM3算法中需要频繁计算的部分，例如S盒替换、常量T的计算等，可以预先计算并存储为查找表，减少重复计算的时间消耗。
5. 算法优化：针对SM3算法本身，可以进一步优化算法的结构和流程，减少冗余计算和内存访问，提高算法的执行效率。
## 优化实现
故我们首先对SM3代码的实现进行优化，摒弃之前的一些用于进制转换，位运算的运算函数，减少浪费的时间，尝试使用unsigned int类型重新实现SM3。

compress函数是SM3算法的核心部分，通过循环迭代运算来计算消息的哈希值。SM3本质上是求哈希值，故整体优化思路是尝试进行多线程实现，测量计算1000次所需的时间，将任务分配到多个线程并行处理。
## 运行结果
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230720171453.png)
## 结果分析
从运行结果来看，四线程相较于单线程运行1000次速度提升了2倍多，但是八线程提升不是很显著，我个人分析和查阅资料后推断产生这种结果的原因可能如下：
1. 线程调度开销：增加线程数量会增加线程间的切换和调度开销。如果系统的线程调度机制导致频繁的线程切换，那么这些开销可能会超过多线程所带来的并行计算的好处，导致性能提升不明显。
2. 数据依赖性：如果并行计算的任务中存在数据依赖性，即某个线程需要依赖其他线程的结果才能继续执行，那么增加线程数量可能无法有效地隐藏这种依赖性，从而无法充分发挥多线程的优势。
3. 内存访问冲突：如果多个线程同时访问相同的内存区域，会引发竞争条件和缓存失效，导致性能下降。


