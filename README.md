# 实验名称
**Merkle-Tree** 

# 实验内容
实现Merkle-Tree

# 作者
姓名：闫子轩

组号：Group105

学号：202100460160

Github账户地址：https://github.com/ZixuanYan

# 软件环境

编译器：Python 3.10，Visual Studio 2019

# Merkle Tree原理
Merkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为Hash tree，如下图：
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230721173126.png)
具体原理如下：
1. 将待验证的数据划分为固定大小的数据块（通常是2的幂次方），每个数据块都有一个唯一的哈希值。
2. 将相邻的两个数据块进行哈希计算，并将结果合并为一个新的哈希值。这个过程称为哈希合并。
3. 重复步骤2，直到最终只剩下一个根哈希值，称为树根。这个树根即为整个数据集的唯一表示。
4. 在验证数据完整性时，如果需要验证某个数据块是否被篡改，只需从该数据块开始，逐级向上计算哈希值，直到树根。然后可以比较树根与预先保存的正确的树根值是否相同。
5. 
Merkle tree的优势在于它提供了高效的数据验证和检索方式，具有以下特点：

1. 数据块的哈希计算可以并行进行，因此可以利用多核或分布式系统来加速计算。
2. 当数据集很大时，树的高度可以较小，而不依赖于数据集的大小，因此验证数据完整性只需要计算树的一小部分。
3. 如果数据块发生改变，只有与该数据块相关的哈希值需要被重新计算，而不必重新计算整个树。
4. 默克尔树可用于构建不可变数据结构，例如区块链中的Merkle根用于验证区块的有效性。

## 运行结果

输入明文“SDUYZX”，得到如下结果：
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230721172848.png)
输出结果中，包括所有结点的哈希值，最后一行第一个元素是Merkle树的根哈希值（即唯一的哈希值），第二个元素是Merkle树的高度。

