# 实验名称
**Merkle-Tree** 

# 实验内容
1. 实现Merkle-Tree
2. 用实际的网络通信实现Merkle Tree

# 作者
姓名：闫子轩

组号：Group105

学号：202100460160

Github账户地址：https://github.com/ZixuanYan

# 软件环境

编译器：Python 3.10，Visual Studio 2019

# Merkle Tree实现
## 实现原理
Merkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为Hash tree，如下图：
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230721173126.png)
具体原理如下：
1. 将待验证的数据划分为固定大小的数据块（通常是2的幂次方），每个数据块都有一个唯一的哈希值。
2. 将相邻的两个数据块进行哈希计算，并将结果合并为一个新的哈希值。这个过程称为哈希合并。
3. 重复步骤2，直到最终只剩下一个根哈希值，称为树根。这个树根即为整个数据集的唯一表示。
4. 在验证数据完整性时，如果需要验证某个数据块是否被篡改，只需从该数据块开始，逐级向上计算哈希值，直到树根。然后可以比较树根与预先保存的正确的树根值是否相同。
5. 
Merkle tree的优势在于它提供了高效的数据验证和检索方式，具有以下特点：

1. 数据块的哈希计算可以并行进行，因此可以利用多核或分布式系统来加速计算。
2. 当数据集很大时，树的高度可以较小，而不依赖于数据集的大小，因此验证数据完整性只需要计算树的一小部分。
3. 如果数据块发生改变，只有与该数据块相关的哈希值需要被重新计算，而不必重新计算整个树。
4. 默克尔树可用于构建不可变数据结构，例如区块链中的Merkle根用于验证区块的有效性。

## 运行结果

输入信息“SDUYZX”，得到如下结果：
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230721172848.png)
输出结果中，包括所有结点的哈希值，最后一行第一个元素是Merkle树的根哈希值（即唯一的哈希值），第二个元素是Merkle树的高度。

# 实际网络实现Merkle Tree
## 实现原理
要实现使用实际的网络通信来实现Merkle Tree协议，需要添加一些功能来处理网络通信和消息传递，使用Python的socket模块实现基本的客户端-服务器通信以执行Merkle Tree协议。

服务器端使用socket模块创建一个服务器套接字，监听传入的连接请求。一旦与客户端建立了连接，服务器端将接收到的数据解析为交易列表，并调用concat_and_hash_list()函数生成Merkle树的根哈希值和树的高度。然后，服务器将根哈希值和树的高度作为响应发送给客户端。

客户端也使用socket模块创建一个客户端套接字，并连接到服务器。然后客户端从用户那里接收交易数据输入，将数据发送给服务器。最后，客户端从服务器接收响应并打印出来。
## 运行结果
输入信息“SDUYZX”，得到如下结果：

服务端：
![](https://zx777-1319535985.cos.ap-beijing.myqcloud.com/20230721180406.png)
客户端：
![9c062fec5aabb6efdb01ef12487d050d.png](:/040baa3720aa409e8fd47d4b1fef8788)
